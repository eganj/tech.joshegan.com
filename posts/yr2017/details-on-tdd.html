<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="HandheldFriendly" content="True"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="description" content="Some details and thoughts on the practice of Test-Driven Development."><meta property="og:description" content="Some details and thoughts on the practice of Test-Driven Development."><meta property="og:site_name" content="tech.joshegan.com"><link rel="stylesheet" type="text/css" href="/styles/third-party/google-fonts/css/google-fonts.css"><link rel="stylesheet" type="text/css" href="/styles/third-party/font-awesome-4.3.0/css/font-awesome.min.css"><link rel="stylesheet" type="text/css" href="/styles/main.css"><meta property="og:title" content="Details on TDD - tech.joshegan.com"><title>Details on TDD - tech.joshegan.com</title><meta property="og:url"><meta property="og:type" content="article"><link rel="stylesheet" type="text/css" href="/styles/third-party/highlight-js/hybrid.css"><script src="/scripts/sidebar-opacity.js"></script></head><body><div class="post-wrapper"><header class="nav mobile-nav"><a href="/"><i class="fa fa-home fa-2x"></i><span>tech.joshegan.com</span></a></header><article class="post"><h1><a>Details on TDD</a></h1><p>Posted on&nbsp;<time datetime="2017-04-12"><strong>Apr 12th, 2017</strong></time>, updated on&nbsp;<time datetime="2018-04-16" class="orange"><strong>Apr 16th, 2018</strong></time></p><p>I was already familiar with unit testing and the concept of TDD (Test-Driven Development) before I started at Pluralsight, but I soon realized that my understanding was just scratching the surface. I have learned much more on this subject so I wanted to do a quick write-up on what I have learned.</p>
<p>As time has gone on, I have continued to add to this post to create a collection of testing resources, articles, and high level concepts. This has made this post more useful as a testing resource and general knowledge page.</p>
<h2>Specific Testing Principles</h2>
<ul>
<li><a href="http://programmer.97things.oreilly.com/wiki/index.php/The_Three_Laws_of_Test-Driven_Development">The Three Laws of TDD</a></li>
<li><a href="http://blog.cleancoder.com/uncle-bob/2014/12/17/TheCyclesOfTDD.html">Red-Green-Refactor Cycle</a></li>
<li><a href="https://martinfowler.com/bliki/TestPyramid.html">Testing Pyramid</a></li>
<li>Clear definitions of different types of tests in the testing pyramid:
<ol>
<li>UI: These tests run against the UI in our staging environment. Nothing is mocked. These tests ensure that everything is working together as expected. These are the most fragile tests and we therefore only test critical paths with these type of tests. For web UI tests, we use tools like <a href="http://docs.seleniumhq.org/">Selenium</a>, <a href="http://nightwatchjs.org/">Nightwatch</a>, and <a href="https://saucelabs.com/">SauceLabs</a>.</li>
<li>Acceptance: These tests are for a single application to ensure that everything in an application is working as expected. Nothing is mocked for these tests. For example, all of our APIs have acceptance tests that make a single happy path pass through each endpoint to ensure that everything is working together as expected. One of the awesome things about Node.js is that our acceptance tests start the api server locally, run the tests, and then shut the server down after the tests have run. So awesome.</li>
<li>Integration: These tests cross exactly one boundary to ensure that an integration with a third party service is working as expected. Typically, integration tests are used for external services (databases, apis, etc.) that require some kind of setup in order to ensure that the service is running prior to executing the tests. For example, a repository that accesses the database would have integration tests to thoroughly test (as thouroughly as we do when unit testing) all the expected usages and edge cases for interacting with the database. These tests never have anything mocked because we <a href="https://github.com/testdouble/contributing-tests/wiki/Don%27t-mock-what-you-don%27t-own">don't mock what we don't own</a>.</li>
<li>Unit: Finally, unit tests are for thoroughly testing all possible outcomes with <em>our</em> code. These tests mock out dependencies and test isolated chunks of code. Again, we don't mock what we don't own.</li>
</ol>
</li>
<li><a href="http://coding-is-like-cooking.info/2013/04/outside-in-development-with-double-loop-tdd/">Double Loop TDD</a></li>
<li><a href="https://github.com/testdouble/contributing-tests/wiki/Don%27t-mock-what-you-don%27t-own">don't mock what we don't own</a></li>
</ul>
<h2>General Testing Practices and Theory</h2>
<h3><a href="http://blog.testdouble.com/posts/2015-11-16-how-to-stop-hating-your-tests">How to stop hating your tests</a></h3>
<p>Talk given by Justin Searls at RubyConf 2015. This 45 minute presentation covers practices to make testing easier.</p>
<p><strong>Test Structure</strong></p>
<ul>
<li>Too big to fail
<ul>
<li>Big objects are hard to deal with.</li>
<li>Tests make big objects even worse.</li>
<li>Big objects tend to have lots of branching logic, which then subjects your test code to the rule of product.</li>
<li>Avoiding large objects will make testing so much easier, not to mention your production code being straight-forward.</li>
<li>Limit new objects to 1 public method and at most 3 dependencies.</li>
</ul>
</li>
<li>Don't got off script
<ul>
<li>Stick to the same pattern of arrange, act, assert or given, when, then for all tests. Getting creative leads to headaches.</li>
<li>If you have a lot of &quot;given&quot; setup, perhaps your subject has too many dependencies.</li>
<li>If you have a lot of &quot;when&quot; scenarios, perhaps you could make your api more user friendly with fewer branches.</li>
<li>If you have a lot of &quot;then&quot; steps, perhaps your code is doing too much.</li>
</ul>
</li>
<li>Hard to read, hard to skim
<ul>
<li>Test code is untested code, so minimize the code in test files.</li>
<li>Avoid logic in test files.</li>
<li>If you're feeling tempted to DRY up your tests, it may be an indicator that your code under test is not designed well.</li>
<li>The ability to read and understand a test quickly trumps DRY test code.</li>
</ul>
</li>
<li>Magic tests
<ul>
<li>Testing libraries can complicate testing if the api is complex.</li>
</ul>
</li>
<li>Accidentally creative
<ul>
<li>Consistency is golden</li>
<li>He always names the thing under test <code>subject</code> and the return value <code>result</code> or <code>results</code>.</li>
<li>In consistency can convey meaning if only one test or suite departs from the norm.</li>
<li>When we read code, we assume everything has meaning. If a value doesn't matter, make it obvious.</li>
</ul>
</li>
</ul>
<p><strong>Test Isolation</strong></p>
<ul>
<li>Unfocused test suites
<ul>
<li>How do you define success in testing?
<ul>
<li>Is it tested?</li>
<li>Is the purpose of the test readily apparent?</li>
<li>Does the test suite promote consistency?</li>
</ul>
</li>
<li>Create separate suites for each type of test.</li>
<li>Use conventions and configuration to promote consistency.</li>
</ul>
</li>
<li>Too realistic
<ul>
<li>More realistic tests are usually not the answer.</li>
<li>Realistic tests:
<ul>
<li>are slower</li>
<li>take more time to write, change, and debug</li>
<li>require higher cognitive load</li>
<li>fail for more reasons</li>
</ul>
</li>
<li>Clear boundaries increase focus on what's tested and what's controlled.</li>
<li>Less integrated, more isolated tests provide better design feedback.</li>
</ul>
</li>
<li>Redundant coverage
<ul>
<li>Redundant test coverage can kill team morale.</li>
<li>Redundant coverage leads to large changes in test files for a single change in a production file.</li>
<li>Avoid redundant coverage by have clear layers for what is being tested.</li>
</ul>
</li>
<li>Careless mocking
<ul>
<li>Mocking should be used to define contracts between modules.</li>
<li>Many people in the world use mocks to &quot;silence&quot; troublesome modules. This is not a good practice.</li>
<li>Bad mocks treat the symptoms of test pain, not the cause.</li>
<li>Bad mocks greatly confuse future test readers</li>
</ul>
</li>
<li>Application frameworks
<ul>
<li>If code does not rely on a framework, neither should the tests.</li>
</ul>
</li>
</ul>
<p><strong>Test Feedback</strong></p>
<ul>
<li>Error messages
<ul>
<li>Make your tests fail with useful error messages. A useful error message will save loads of time.</li>
<li>Judge assertion libraries on their message quality, not only on their api.</li>
</ul>
</li>
<li>Slow feedback loops
<ul>
<li>You have 480 minutes in every workday. How many feedback loops can you get in during the day?</li>
<li>Little nuances in your testing practices can really increase the feedback loop time.</li>
<li>Keep your tests fast and your test error messages really useful.</li>
</ul>
</li>
<li>Painful data
<ul>
<li>Thoughtfully approach your strategy for how to setup data for tests.</li>
<li>Inline data creation is a great approach for unit tests.</li>
<li>Test fixtures might be useful for integration or acceptance suites.</li>
<li>Data dumps might be useful for UI tests.</li>
<li>&quot;Self-priming&quot; is probably the only option for stage or production tests.</li>
<li>Slow tests are often slow because of data setup.</li>
</ul>
</li>
<li>Superlinear build slow-down
<ul>
<li>As you keep adding code to existing functions along with tests to your suite, the build time tends to grow exponentially instead of linearly.</li>
<li>Keep integration tests to a minimum. Get as much as you can out of each test.</li>
<li>Early on, set a firm cap on build duration - and enforce it!</li>
</ul>
</li>
<li>False Negatives
<ul>
<li>What does it mean when the build fails?</li>
<li>Was a test broken, or was the code broken?</li>
<li>true negatives reinforce the value of our tests. But they are depressingly rare.</li>
<li>false negatives erode our confidence in our test suite. Quickly becomes a drain.</li>
<li>Top causes of false negatives:
<ul>
<li>Redundant test coverage</li>
<li>Slow tests</li>
</ul>
</li>
<li>Try tracking how many false negatives you get in your tests and how long they take to fix.</li>
</ul>
</li>
</ul>
<h3><a href="https://blog.testdouble.com/posts/2018-03-06-please-dont-mock-me">Please don't mock me</a></h3>
<p>Talk given by Justin Searls at the Assert.js 2018 conference. In this one hour presentation he covers a lot of topics related to testing and design including:</p>
<ul>
<li>Never use partial mocks of a dependency. Mock the entire dependency, not just select functions.</li>
<li>Never mock parts of the subject under test. If you find you need to mock parts of the subject under test, that is a glaring signal to refactor and break up the subject code.</li>
<li>Never partially mock dependencies - either mock all of them or none of them.</li>
<li>Create a wrapper around external modules so that external modules don't spread through your application. Wrappers do not necessarily need to be tested.</li>
<li>&quot;Hard to mock code is hard to use code&quot;</li>
<li>Every function should either test relationships or logic, but never both. Avoid mixed levels of abstraction.</li>
<li>Understand that tests are designed to fail. Know what should cause your tests to fail.
<ul>
<li>A test on a function that manages logic will need to be updated if the logic changes.</li>
<li>A test on a function that manages relationships will need to be updated if the contracts change.</li>
</ul>
</li>
<li>Don't mock intermediate modules. Either mock the direct dependency or mock the furthest possible connection point. Avoid mocking some random module in the middle.</li>
<li>Mock dependencies, but pass real values.</li>
<li>If you're dealing with legacy code, start by writing high level acceptance tests.</li>
<li>If you're using mocks to silence side-effects, note that's a smell and modify code design to avoid side effects.</li>
<li>Allow isolated unit tests to influence the design of your code.</li>
<li>Take care with how you design assertions, because it can influence code design. Functions should typically return a value. Any function that doesn't return a value likely is a side effect.</li>
<li>When dependency functions are stubbed, you shouldn't need an assertion that the dependent function was called.</li>
<li>Using solid testing practices greatly contributes to:
<ul>
<li>reliable incremental progress</li>
<li>single-responsibility functions</li>
<li>intention-revealing names</li>
<li>discoverable organization</li>
<li>separate values and logic</li>
<li>most functions are synchronous, pure functions</li>
</ul>
</li>
</ul>
<h3><a href="http://blog.testdouble.com/posts/2014-05-25-breaking-up-with-your-test-suite">Breaking up with your test suite</a></h3>
<p>Talk given by Justin Searls on April 3rd, 2014.</p>
<ul>
<li>&quot;I get paid for code that works, not for tests, so my philosophy is to test as little as possible to reach a given level of confidence.&quot; - Kent Beck</li>
<li>Each test suite should be targeted to provide 1 level of conifidence or 1 layer of understanding.</li>
<li>App level (entire application - e.g. web UI tests that rely on all services, APIs, etc. to be up and running)
<ul>
<li>Tests for this level are called by many names (Smoke, Acceptance, Feature, End-to-end) (SAFE tests)</li>
<li>Should be written from the perspective of the end user.</li>
<li>Should provide confidence that everything works when it's all glued together.</li>
<li>Should provide understanding of how simple and easy to use your application is.
<ul>
<li>If it takes more than 30 minutes to run through every possible user endpoint, your application is not simple.</li>
<li>If it takes more than 30 minutes to write a test for a new user endpoint, your application is not simple.</li>
</ul>
</li>
<li>The tests should not have any knowledge beyond the public interface. No implementation details of internal apis, libraries, etc. should be used by these tests.</li>
<li>Enforce a fixed time budget. Choose a maximum amount of time that you're willing to wait while the tests run. Never go over that amount of time. If the amount of time is ever exceeded, either tests need to be removed or you need to create a new suite that can run in parallel with the existing suite.</li>
</ul>
</li>
<li>Micro-service level (a single service, for example an API)
<ul>
<li>Again, various names for these type of tests. Integration is one, although he hates that word because it is the most overloaded when it comes to testing. He calls them &quot;Consumption&quot; tests.</li>
<li>Should written from the perspective of the consumer of the service.</li>
<li>Should verify behavior that the service is <em>directly</em> responsible for.</li>
<li>Should provide understanding of whether or not it is easy to use.</li>
<li>Module boundaries should be meaningful beyond testing.</li>
<li>Fake all external dependencies. Should be able to run the tests without external services running.</li>
<li>Only use public APIs</li>
<li>Organize the tests by the consumer's desired outcomes.</li>
<li>Keep these tests really fast. If they're slow, and external dependencies are faked, then you know it's your fault if they're slow.</li>
</ul>
</li>
<li>Inter-service tests - write these type of tests to verify that other services are behaving the way you expect them to behave.
<ul>
<li>He calls them Contract tests.</li>
<li>These tests are written from the developer's perspective, to ensure that some 3rd party service is doing what you expect it to do.</li>
<li>Include these tests in the other repo's consumption suite if it is an internal application. Include your contact info so that if the tests break the other team knows who to get a hold of.</li>
<li>The goal here is speedier feedback. If another team breaks something that you depend on, they will know immediately when the test fails.</li>
<li>Should provide confidence that our dependencies behave the way we need them to.</li>
<li>Should provide understanding about whether or not the service meets our needs.</li>
<li>Frequent test failures may reveal differing priorities.</li>
<li>Reveals to the maintainers of the project how their service is being used.</li>
<li>If one of the consumers is using the service in a weird way, then perhaps recommend a different service or writing a new one.</li>
<li>If all of the consumers are using the service in a weird way, then perhaps the service needs to be re-designed to better meet the needs it is supposed to meet.</li>
</ul>
</li>
<li>Class level tests - unit tests
<ul>
<li>He calls them &quot;Discovery tests&quot; because the principle value he derives from these tests is discovering good code design.</li>
<li>Discover tiny, boring, consistent units of code that break down big, scary problems into small manageable ones.</li>
<li>The user of these tests is the first person to call a function. They are concerned with the inputs, outputs, and side effects if any.</li>
<li>Concerned with basic code design. Tightly coupled to the implementation.</li>
<li>Should provide confidence of logical leaf nodes.</li>
<li>Should lead to small, focused units of code. Makes SRP easy.</li>
</ul>
</li>
<li>Adapter tests
<ul>
<li>These are tests against a 3rd party service that you have no control over.</li>
<li>Written from the standpoint of your application trying to understand how to interact with the 3rd party service.</li>
<li>Tests should be written in the most realistic context possible.</li>
<li>Should provide confidence that your code will work when the 3rd party service changes.</li>
<li>Should provide information about outages and breaking changes.</li>
<li>Should help you understand which parts of the 3rd party service you depend on and how you are using those parts.</li>
<li>Establishes boundaries; prevents 3rd party references from leaking into your app.</li>
<li>All of this reduces the cost of replacing dependencies later.</li>
<li>Only test adapters when you have good reason to. For the most part, trust that the 3rd party library does what it's supposed to. Most of the time you should be able to write an adapter without worrying about testing the adapter.</li>
<li>Adapter test suites can be tricky to run, so be mindful of the gotchas you might run into for a given adapter.</li>
<li>Sometimes it might make more sense to test 3rd party services from the SAFE test suite (highest level).</li>
<li>Adapter tests tend to be slow, and the speed is outside your control.</li>
</ul>
</li>
</ul>
<h2>Testing Tools</h2>
<p>For acceptance, integration, and unit tests, I have used the following libraries:</p>
<ul>
<li><a href="http://mochajs.org/">mocha</a> with <code>bdd</code> style.</li>
<li><a href="http://chaijs.com/">chai</a> with the <code>expect</code> assertions because <code>expect(undefined).to.equal('foo')</code> will execute whereas <code>undefined.should.equal('foo')</code> will explode. Also use the <a href="http://chaijs.com/plugins/chai-as-promised/">chai-as-promised</a> plugin.</li>
<li><a href="https://shouldjs.github.io/">should</a> for fluent assertions.</li>
<li><a href="https://github.com/testdouble/testdouble.js">testdouble</a> for mocking. This is my preferred mocking library - I have dealt with many of <a href="http://blog.testdouble.com/posts/2016-03-13-testdouble-vs-sinon.html">these</a> pain points.</li>
<li><a href="http://sinonjs.org/">sinon</a> for mocking.</li>
</ul>
<p>I have used the following tools for executing tests:</p>
<ul>
<li>I most often run tests using <code>mocha</code>'s built in <code>--watch</code> mode.</li>
<li><a href="https://www.jetbrains.com/webstorm/">WebStorm</a> has an excellent built in test runner that works seamlessly with <code>mocha</code>. One of the best parts of using WebStorm to run tests is having clickable links in the stack traces.</li>
<li><a href="https://wallabyjs.com/">Wallaby.js</a> is a continuous test runner that integrates with numerous text editors. I used this heavily for about 6 months, and it was awesome, but in the end this tool fell out of use because it was too much work to keep it configured on all of the workstations. (At Pluralsight, no one on our team has a desk - we paired / mobbed everyday so there is no personal space. Consequently, keeping wallaby running required configuring it on every workstation for every project, and the overhead grew to be too tiring for me and outweighed the benefits. Just using the WebStorm runner in continuous execution mode has been good enough for me.)</li>
</ul>
<p>For testing React components, here are a couple of insightful articles:</p>
<ul>
<li><a href="https://medium.freecodecamp.org/the-right-way-to-test-react-components-548a4736ab22">The Right Way to Test React Components</a></li>
<li><a href="https://medium.com/netscape/testing-a-react-redux-app-using-jest-and-enzyme-b349324803a9">Testing a React-Redux app using Jest and Enzyme</a></li>
</ul>
<h2>Value of Tests</h2>
<p>We've had lots of discussions about how to test and what to test. The purpose of testing is to deliver features faster with very few bugs. So our tests are written with that end-goal in mind. We generally follow the shape of the testing pyramid; in other words we typically test in a (off the cuff) ratio of 50:15:5:1. However, like most things, there are exceptions to every rule. For example, in one project, we have abstracted most of the functionality into re-usable, private npm packages because each implementation was so similar. Each npm package is thoroughly unit tested, so in that project we only have acceptance tests and the acceptance tests cover all of the possible paths. We have found that even though the acceptance tests take a little longer to run than unit tests, it's faster in the end to write and maintain these tests for this particular project.</p>
<h2>Testing Scripts</h2>
<p>Some tips for making npm scripts work well:</p>
<ul>
<li>Use escaped double quotes around file blobs to ensure that they work on Mac, PC, and Linux.</li>
<li>How to get rid of the ~20 lines of error output that npm pukes out after a failed script?
<ul>
<li>Use the <code>--silent</code> flag from the command line, e.g. <code>npm test --silent</code>.</li>
<li>Add <code>loglevel=silent</code> to your <code>.npmrc</code> to set the log level to silent for every npm process.</li>
<li>Use <code>|| true</code> at the end of your test script to prevent npm from puking all of the error output at the end of a failed test.</li>
<li>Make sure <em>not</em> to use <code>|| true</code> if your test script is going to be run in a tool like TeamCity where a failure needs to be meaningful.</li>
</ul>
</li>
</ul>
<pre><code class="language-json">{
  "<span class="hljs-attribute">scripts</span>": <span class="hljs-value">{
    "<span class="hljs-attribute">test</span>": <span class="hljs-value"><span class="hljs-string">"./node_modules/.bin/mocha \"./src/**/*.specs.js\""</span></span>,
    "<span class="hljs-attribute">test-watch</span>": <span class="hljs-value"><span class="hljs-string">"npm test -- -w"</span></span>,
    "<span class="hljs-attribute">test-teamcity</span>": <span class="hljs-value"><span class="hljs-string">"npm test -- --reporter mocha-teamcity-reporter"</span></span>,
    "<span class="hljs-attribute">ti</span>": <span class="hljs-value"><span class="hljs-string">"./node_modules/.bin/mocha ./test/database-setup.js \"./src/**/*.i-specs.js\" || true"</span></span>,
    "<span class="hljs-attribute">ti-watch</span>": <span class="hljs-value"><span class="hljs-string">"npm run test-integration -- -w"</span></span>,
    "<span class="hljs-attribute">test-integration</span>": <span class="hljs-value"><span class="hljs-string">"./node_modules/.bin/mocha ./test/database-setup.js \"./src/**/*.i-specs.js\""</span></span>,
    "<span class="hljs-attribute">test-integration-teamcity</span>": <span class="hljs-value"><span class="hljs-string">"npm run test-integration -- --reporter mocha-teamcity-reporter"</span></span>,
    "<span class="hljs-attribute">ta</span>": <span class="hljs-value"><span class="hljs-string">"./node_modules/.bin/mocha \"./src/**/*.a-specs.js\" || true"</span></span>,
    "<span class="hljs-attribute">test-acceptance</span>": <span class="hljs-value"><span class="hljs-string">"./node_modules/.bin/mocha \"./src/**/*.a-specs.js\""</span></span>,
    "<span class="hljs-attribute">test-acceptance-teamcity</span>": <span class="hljs-value"><span class="hljs-string">"npm run test-acceptance -- --reporter mocha-teamcity-reporter"</span></span>,
    "<span class="hljs-attribute">test-all</span>": <span class="hljs-value"><span class="hljs-string">"npm test &amp;&amp; npm run test-integration &amp;&amp; npm run test-acceptance"</span>
  </span>}
</span>}
</code></pre></article><div id="sidebar" class="nav tablet-sidebar"><a href="/"><i class="fa fa-home fa-2x"></i><span>tech.joshegan.com</span></a><div class="author-profile"><img alt="author image" src="//www.gravatar.com/avatar/bd6b4be626e8bc1b30161f22a0de08ae?d=404&amp;amp;s=250" class="author-img"><div class="info"><h5>Josh Egan</h5><ul class="social"><li><a href="https://github.com/josh-egan" target="_blank" class="github"><i class="fa fa-github"></i></a></li></ul></div></div></div><div class="mobile-author-profile"><div class="separator"></div><div class="author-profile"><img alt="author image" src="//www.gravatar.com/avatar/bd6b4be626e8bc1b30161f22a0de08ae?d=404&amp;amp;s=250" class="author-img"><div class="info"><h5>Josh Egan</h5><ul class="social"><li><a href="https://github.com/josh-egan" target="_blank" class="github"><i class="fa fa-github"></i></a></li></ul></div></div><div class="separator"></div></div><div><div id="disqus_thread"></div><script type="text/javascript" async="true" src="//tech-joshegan.disqus.com/embed.js"></script><noscript>Please enable JavaScript to view the<a href="https://disqus.com/?ref_noscript" rel="nofollow">comments powered by Disqus.</a></noscript></div></div><div class="separator"></div><footer><div><span>Proudly built with <a href="http://harpjs.com/" target="_blank">harp </a>and hosted on <a href="https://github.com/josh-egan/tech.joshegan.com/tree/master" target="_blank">GitHub</a></span></div></footer></body></html>